<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8">
<title>Brioude 2026, a tale of AURA</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
  body{
    margin:0;
    background:#000;
    display:flex;
    justify-content:center;
    align-items:center;
    height:100vh;
  }
  canvas{
    width:640px;
    height:480px;
    image-rendering:pixelated;
    background:#f3f0da;
  }
</style>
</head>
<body>

<canvas id="game" width="320" height="240"></canvas>

<script>
(()=>{

/* =====================
   CANVAS
===================== */
const canvas=document.getElementById("game");
const ctx=canvas.getContext("2d");
ctx.imageSmoothingEnabled=false;
ctx.font="12px monospace";
ctx.textBaseline="alphabetic";
const W=canvas.width,H=canvas.height;

/* =====================
   ASSETS
===================== */
const ASSETS={
  sprites:{
    remy_back:"remy_back.png",
    wauquiez_front:"wauquiez_front.png",
    ciotti_front:"ciotti_front.png",
    maite_front:"maite_front.png",
    edile_front:"edile_front.png"
  },
  background:{ battle:"battle_bg.png" },
  ui:{ cursor:"cursor.png", textbox:"textbox.png" }
};

const IMG={};
function preloadAssets(done){
  const list=[];
  Object.values(ASSETS).forEach(group=>{
    Object.entries(group).forEach(([k,src])=>list.push([k,src]));
  });

  if(list.length===0){ done(); return; }

  let loaded=0;
  list.forEach(([k,src])=>{
    const i=new Image();
    i.onload=()=>{ IMG[k]=i; if(++loaded===list.length) done(); };
    i.onerror=()=>{ console.warn("Missing:",src); if(++loaded===list.length) done(); };
    i.src=src;
  });
}

/* =====================
   UTILS
===================== */
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const chance=p=>Math.random()<p;
const randInt=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;

/* =====================
   FX (ANIMS)
===================== */
const FX={
  shakeX:0, shakeY:0, shakeFrames:0,
  flashFrames:0,
  overlay:null,   // {kind,x,y,t,frames}
  floatTexts:[],  // [{text,x,y,vy,frames}]
  hitAnim:{ player:0, enemy:0 } // bounce timer
};

function startShake(kind="hit"){
  FX.shakeFrames = (kind==="heavy") ? 10 : 6;
}
function flash(frames=2){
  FX.flashFrames = Math.max(FX.flashFrames, frames);
}
function setOverlay(kind,x,y,frames=18){
  FX.overlay = {kind,x,y,t:0,frames};
}
function addFloatText(text,x,y){
  FX.floatTexts.push({text,x,y,vy:-0.25,frames:42});
}

function updateFX(){
  if(FX.shakeFrames>0){
    FX.shakeX=(Math.random()-0.5)*6;
    FX.shakeY=(Math.random()-0.5)*4;
    FX.shakeFrames--;
  } else {
    FX.shakeX=FX.shakeY=0;
  }

  if(FX.flashFrames>0) FX.flashFrames--;

  if(FX.overlay){
    FX.overlay.t++;
    FX.overlay.frames--;
    if(FX.overlay.frames<=0) FX.overlay=null;
  }

  FX.floatTexts.forEach(ft=>{
    ft.y += ft.vy;
    ft.frames--;
  });
  FX.floatTexts = FX.floatTexts.filter(ft=>ft.frames>0);

  if(FX.hitAnim.player>0) FX.hitAnim.player--;
  if(FX.hitAnim.enemy>0) FX.hitAnim.enemy--;
}

/* =====================
   TYPES (multiplicateurs cumulables)
===================== */
const TYPE_CHART={
  action:{ blague:2, parisianisme:0.5 },
  blague:{ parisianisme:2, recherche:0.5 },
  recherche:{ blague:2, parisianisme:0.5 },
  parisianisme:{ action:2, tradition:0.5 },
  tradition:{ parisianisme:2, recherche:0.5 }
};

function typeMultiplier(atkType,defTypes){
  let m=1;
  for(let i=0;i<defTypes.length;i++){
    const t=defTypes[i];
    const row=TYPE_CHART[atkType];
    const v=row ? row[t] : null;
    if(v) m*=v;
  }
  return m;
}

/* =====================
   UI TEXTE / MENU
   (FIX: showText NE ferme plus le menu,
   donc une fois les textes finis, le menu r√©appara√Æt)
===================== */
const UI={
  text:"",visible:"",idx:0,typing:false,timer:0,
  queue:[],
  menu:false,items:[],menuIdx:0,
  cooldown:0
};

function showText(t){
  UI.text=t;
  UI.visible="";
  UI.idx=0;
  UI.typing=true;
  UI.timer=0;
}
function updateText(dt){
  if(!UI.typing) return;
  UI.timer+=dt;
  while(UI.timer>28 && UI.idx<UI.text.length){
    UI.visible+=UI.text[UI.idx++];
    UI.timer-=28;
  }
  if(UI.idx>=UI.text.length) UI.typing=false;
}
function nextText(){
  if(UI.typing){
    UI.visible=UI.text;
    UI.typing=false;
    return true;
  }
  if(UI.queue.length){
    showText(UI.queue.shift());
    return true;
  }
  UI.text="";
  UI.visible="";
  return false;
}
function playMessages(lines){
  const msgs=(lines||[]).filter(Boolean);
  if(msgs.length===0){
    UI.text="";UI.visible="";UI.queue=[];
    return;
  }
  showText(msgs.shift());
  UI.queue = msgs;
}
function openMenu(items){
  UI.menu=true;
  UI.items=items.slice();
  UI.menuIdx=0;
}

/* =====================
   FIGHTERS (base + stages)
===================== */
function stageMultiplier(stage){
  const s=clamp(stage,-6,6);
  if(s>=0) return 1 + s*0.15;
  return 1 + s*0.10;
}
function createFighter(name,types,stats,sprite){
  return{
    name,types,sprite,
    maxHP:100,
    hp:100,
    hpVis:100,
    base:{ atk:stats.atk, def:stats.def, spd:stats.spd },
    mods:{ atk:0, def:0, spd:0 },
    status:{ burn:false, sleep:0, confusion:0, protect:0 },
    moves:[]
  };
}
function effectiveStat(f,key){
  let v=Math.floor(f.base[key]*stageMultiplier(f.mods[key]||0));
  // Burn = malus d'attaque (lisible + Pokemon-like)
  if(key==="atk" && f.status.burn) v=Math.floor(v*0.5);
  return Math.max(1,v);
}
function resetFighter(f){
  f.hp=f.maxHP;
  f.hpVis=f.maxHP;
  f.mods={ atk:0, def:0, spd:0 };
  f.status={ burn:false, sleep:0, confusion:0, protect:0 };
}

/* =====================
   COORDS (pour FX)
===================== */
let enemy=null; // d√©clar√© ici pour coordsFor, assign√© au combat
const player=createFighter(
  "Remy",
  ["recherche","blague"],
  {atk:55,def:50,spd:60},
  "remy_back"
);

function coordsFor(f){
  const isPlayer=(f===player);
  return { x:isPlayer?70:240, y:isPlayer?130:70 };
}

/* =====================
   MOVES (Pokemon-like + "signature" par boss)
   - power=0 => move de statut
   - effects[] => { kind, target, chance, turns, value, stat, delta }
===================== */
const MOVES_PLAYER=[
  { name:"Cahier de recherche", type:"recherche", power:24, effects:[] },
  { name:"Plaidoyer", type:"action", power:18, effects:[
    { kind:"confusion", target:"enemy", chance:0.40, turns:[2,4] }
  ]},
  { name:"Bourree auvergnate", type:"tradition", power:28, effects:[] },
  { name:"Second degre", type:"blague", power:20, effects:[
    { kind:"burn", target:"enemy", chance:0.30 }
  ]}
];

/* Signature moves :
   - Wauquiez = contr√¥le : sleep fiable + tempo (buff vitesse/attaque)
   - Ciotti   = tank : protect + gros def up + burn (debuff)
   - Maite    = sustain/burst : heal + gros coup avec contrepartie (self sleep)
   - L'Edile  = buff/pression : buffs + protect + confusion
*/
const MOVES_WAUQUIEZ=[
  { name:"Dotations publiques", type:"action", power:14, effects:[
    { kind:"sleep", target:"enemy", chance:0.55, turns:[1,2] }
  ]},
  { name:"Ce que les francais veulent", type:"parisianisme", power:0, effects:[
    { kind:"stat", target:"self", stat:"atk", delta:+1 },
    { kind:"stat", target:"self", stat:"spd", delta:+1 }
  ]},
  { name:"Mauvaise foi", type:"blague", power:22, effects:[] },
  { name:"Bottes en caoutchouc", type:"tradition", power:18, effects:[
    { kind:"confusion", target:"enemy", chance:0.25, turns:[1,3] }
  ]}
];

const MOVES_CIOTTI=[
  { name:"Retranchement", type:"parisianisme", power:0, effects:[
    { kind:"protect", target:"self", chance:1.0 }
  ]},
  { name:"Chauvinisme", type:"parisianisme", power:0, effects:[
    { kind:"stat", target:"self", stat:"def", delta:+2 }
  ]},
  { name:"Accent chantant", type:"tradition", power:20, effects:[] },
  { name:"UDR", type:"blague", power:16, effects:[
    { kind:"burn", target:"enemy", chance:0.40 }
  ]}
];

const MOVES_MAITE=[
  { name:"Ortolan", type:"tradition", power:0, effects:[
    { kind:"heal", target:"self", value:24 }
  ]},
  { name:"Aiguille", type:"tradition", power:18, effects:[
    { kind:"stat", target:"self", stat:"atk", delta:+1 },
    { kind:"confusion", target:"enemy", chance:0.30, turns:[1,3] }
  ]},
  { name:"Indigestion", type:"tradition", power:32, effects:[
    // Contrepartie "Pokemon-like": gros degats, puis auto-sommeil
    { kind:"sleep", target:"self", chance:1.00, turns:[1,2] }
  ]},
  { name:"Icone", type:"blague", power:0, effects:[
    { kind:"stat", target:"self", stat:"atk", delta:+1 }
  ]}
];

const MOVES_EDILE=[
  { name:"Conseil municipal", type:"action", power:0, effects:[
    { kind:"stat", target:"self", stat:"def", delta:+1 },
    { kind:"stat", target:"self", stat:"atk", delta:+1 }
  ]},
  { name:"Clientelisme", type:"action", power:16, effects:[
    { kind:"stat", target:"self", stat:"def", delta:+1 }
  ]},
  { name:"Monsieur le maire", type:"action", power:0, effects:[
    { kind:"protect", target:"self", chance:1.0 }
  ]},
  { name:"Bon sens paysan", type:"tradition", power:22, effects:[
    { kind:"confusion", target:"enemy", chance:0.25, turns:[1,3] }
  ]}
];

/* =====================
   CAMPAIGN (adversaires + movesets uniques)
===================== */
const CAMPAIGN=[
  {
    name:"Laurent Wauquiez",
    sprite:"wauquiez_front",
    types:["parisianisme"],
    stats:{atk:60,def:45,spd:50},
    moves:MOVES_WAUQUIEZ,
    quote:"Moi, je connais les territoires Remy."
  },
  {
    name:"Eric Ciotti",
    sprite:"ciotti_front",
    types:["blague"],
    stats:{atk:48,def:65,spd:55},
    moves:MOVES_CIOTTI,
    quote:"C'est quand il y en a beaucoup que ca pose des problemes."
  },
  {
    name:"Maite",
    sprite:"maite_front",
    types:["tradition"],
    stats:{atk:65,def:55,spd:35},
    moves:MOVES_MAITE,
    quote:"Miam miam."
  },
  {
    name:"L'Edile",
    sprite:"edile_front",
    types:["action"],
    stats:{atk:50,def:60,spd:40},
    moves:MOVES_EDILE,
    quote:"Brioude ne sera jamais autrement."
  }
];

player.moves = MOVES_PLAYER;

/* =====================
   COMBAT CORE
===================== */
function computeDamage(attacker,defender,move){
  const atk=effectiveStat(attacker,"atk");
  const def=effectiveStat(defender,"def");

  const base=(atk/def)*move.power;
  const randFactor=0.85+Math.random()*0.15;
  const mult=typeMultiplier(move.type, defender.types);

  const spd=effectiveStat(attacker,"spd");
  const critChance=clamp(0.06 + spd/220, 0.06, 0.20);
  const isCrit=chance(critChance);

  const dmg=Math.max(1, Math.floor(base*randFactor*mult*(isCrit?1.9:1)));
  return { dmg, mult, isCrit };
}

function applyDamage(target, amount, opts={}){
  target.hp = clamp(target.hp - amount, 0, target.maxHP);

  const {x,y}=coordsFor(target);
  addFloatText(String(amount), x, y);
  if(opts.floatLabel) addFloatText(opts.floatLabel, x, y-12);

  if(target===player) FX.hitAnim.player=10;
  else FX.hitAnim.enemy=10;
}

/* =====================
   STATUTS : burn / sleep / confusion + protect
===================== */
function canAct(f, msgs){
  if(f.status.sleep>0){
    f.status.sleep--;
    msgs.push(f.name+" dort...");
    const c=coordsFor(f);
    setOverlay("sleep", c.x, c.y, 18);
    return false;
  }
  if(f.status.confusion>0){
    f.status.confusion--;
    msgs.push(f.name+" est confus...");
    const c=coordsFor(f);
    setOverlay("confusion", c.x, c.y, 18);

    if(chance(0.5)){
      const dmg=Math.max(1,Math.floor(f.maxHP*0.08));
      applyDamage(f, dmg, {floatLabel:"-CONFUSION"});
      msgs.push("Il se blesse dans sa confusion !");
      return false;
    }
  }
  return true;
}

function burnTick(f, msgs){
  if(!f.status.burn) return;
  const dmg=Math.max(1,Math.floor(f.maxHP*0.06));
  msgs.push(f.name+" souffre de sa brulure !");
  const c=coordsFor(f);
  setOverlay("burn", c.x, c.y, 18);
  applyDamage(f, dmg, {floatLabel:"-BRULURE"});
}

function endTurnTick(f){
  if(f.status.protect>0) f.status.protect--; // protect = 1 tour
}

/* =====================
   APPLY EFFECTS (moves)
===================== */
function moveHitsDefender(move){
  if(move.power>0) return true;
  if(!move.effects) return false;
  for(let i=0;i<move.effects.length;i++){
    if(move.effects[i].target==="enemy") return true;
  }
  return false;
}

function applyEffects(attacker, defender, move, msgs){
  const effects = move.effects || [];
  for(let i=0;i<effects.length;i++){
    const e = effects[i];
    const target = (e.target==="self") ? attacker : defender;
    const c = coordsFor(target);

    const p = (typeof e.chance==="number") ? e.chance : 1.0;
    if(p < 1.0 && !chance(p)) continue;

    if(e.kind==="burn"){
      if(!target.status.burn){
        target.status.burn=true;
        msgs.push(target.name+" est brule !");
        setOverlay("burn", c.x, c.y, 18);
        addFloatText("BRULE", c.x, c.y-12);
      }
      continue;
    }

    if(e.kind==="sleep"){
      if(target.status.sleep===0){
        const turns = e.turns ? randInt(e.turns[0], e.turns[1]) : randInt(1,2);
        target.status.sleep = turns;
        msgs.push(target.name+" s'endort !");
        setOverlay("sleep", c.x, c.y, 18);
        addFloatText("SOMMEIL", c.x, c.y-12);
      }
      continue;
    }

    if(e.kind==="confusion"){
      const turns = e.turns ? randInt(e.turns[0], e.turns[1]) : randInt(2,4);
      target.status.confusion = turns;
      msgs.push(target.name+" est confus !");
      setOverlay("confusion", c.x, c.y, 18);
      addFloatText("CONFUS", c.x, c.y-12);
      continue;
    }

    if(e.kind==="protect"){
      if(target.status.protect===0){
        target.status.protect=1;
        msgs.push(target.name+" se protege !");
        setOverlay("protect", c.x, c.y, 18);
        addFloatText("PROTECT", c.x, c.y-12);
      }
      continue;
    }

    if(e.kind==="heal"){
      const value = Math.max(0, e.value|0);
      if(value>0){
        const before=target.hp;
        target.hp = clamp(target.hp + value, 0, target.maxHP);
        const healed = target.hp - before;
        if(healed>0){
          msgs.push(target.name+" recupere des forces !");
          setOverlay("heal", c.x, c.y, 18);
          addFloatText("+"+healed, c.x, c.y);
        }
      }
      continue;
    }

    if(e.kind==="stat"){
      const stat=e.stat;
      const delta=e.delta|0;
      if(stat && delta){
        target.mods[stat] = clamp((target.mods[stat]||0) + delta, -6, 6);
        const label = (delta>0?"+":"") + delta + " " + stat.toUpperCase();
        addFloatText(label, c.x, c.y-2);
        msgs.push(target.name+" ajuste sa posture !");
      }
      continue;
    }
  }
}

function applyMove(attacker, defender, move, msgs){
  // Protect : bloque un move qui touche le defenseur (degats OU statut)
  if(defender.status.protect>0 && moveHitsDefender(move)){
    msgs.push("Mais ca n'atteint pas la cible !");
    const c=coordsFor(defender);
    setOverlay("protect", c.x, c.y, 18);
    defender.status.protect=0; // consomm√©
    return;
  }

  // Move de degats
  if(move.power>0){
    startShake("hit");

    const {dmg,mult,isCrit}=computeDamage(attacker, defender, move);

    if(isCrit){ msgs.push("Coup critique !"); flash(3); }
    if(mult>1) msgs.push("C'est tres efficace !");
    if(mult<1) msgs.push("Ce n'est pas tres efficace...");

    applyDamage(defender, dmg);
    msgs.push(defender.name+" perd "+dmg+" HP.");
  }

  // Effets (status/buffs/heal/protect)
  applyEffects(attacker, defender, move, msgs);
}

/* =====================
   IA ENNEMIE (types + statuts + contexte)
===================== */
function scoreEnemyMove(enemyF, playerF, move){
  let score = 0;

  // Priorit√© : contr√¥le si le joueur peut √™tre bloqu√©
  const mult = typeMultiplier(move.type, playerF.types);

  // D√©g√¢ts attendus (approx, sans random/crit)
  if(move.power>0){
    const atk=effectiveStat(enemyF,"atk");
    const def=effectiveStat(playerF,"def");
    const expected = (atk/def) * move.power * mult;
    score += expected;
  } else {
    // Move de statut : base de score (sinon l'IA n'en joue jamais)
    score += 8;
  }

  // Valorisation type advantage
  if(mult>1) score += 12;
  if(mult<1) score -= 6;

  // Valorisation des effets utiles (Pokemon-like)
  const effects = move.effects || [];
  for(let i=0;i<effects.length;i++){
    const e=effects[i];

    if(e.kind==="sleep" && e.target==="enemy" && playerF.status.sleep===0) score += 28;
    if(e.kind==="confusion" && e.target==="enemy" && playerF.status.confusion===0) score += 16;
    if(e.kind==="burn" && e.target==="enemy" && !playerF.status.burn) score += 18;

    if(e.kind==="heal" && e.target==="self"){
      if(enemyF.hp < 45) score += 30;
      else score -= 8; // heal inutile si full HP
    }

    if(e.kind==="protect" && e.target==="self"){
      if(enemyF.status.protect>0) score -= 10;
      else if(enemyF.hp < 40) score += 22;
      else score += 6; // parfois utile m√™me pas low
    }

    if(e.kind==="stat" && e.target==="self"){
      // buff utile si pas d√©j√† haut
      const s = enemyF.mods[e.stat]||0;
      if(s < 3) score += 10;
      else score -= 6;
    }
  }

  // Finisher si player low HP
  if(playerF.hp < 30 && move.power>0) score += 18;

  // L√©g√®re p√©nalit√© si ennemi br√ªl√© (prudence)
  if(enemyF.status.burn) score -= 4;

  // Bruit anti-robot
  score += Math.random()*6;

  return score;
}

function chooseEnemyMove(enemyF, playerF){
  let best=null;
  let bestScore=-Infinity;

  for(let i=0;i<enemyF.moves.length;i++){
    const m=enemyF.moves[i];
    const s=scoreEnemyMove(enemyF, playerF, m);
    if(s>bestScore){
      bestScore=s;
      best=m;
    }
  }

  // petite chance de varier (√©vite le "toujours le m√™me")
  if(enemyF.moves.length>1 && chance(0.18)){
    const alt = enemyF.moves[randInt(0, enemyF.moves.length-1)];
    return alt;
  }

  return best || enemyF.moves[0];
}

/* =====================
   TOUR (ordre Pokemon-like via SPD)
===================== */
function computeOrder(){
  const ps=effectiveStat(player,"spd");
  const es=effectiveStat(enemy,"spd");
  if(ps===es) return chance(0.5) ? ["player","enemy"] : ["enemy","player"];
  return (ps>es) ? ["player","enemy"] : ["enemy","player"];
}

/* =====================
   GAME FLOW
===================== */
let gameState="TITLE"; // TITLE | FIGHT | ENDING
let fightIndex=0;

function startTitle(){
  gameState="TITLE";
  fightIndex=0;
  enemy=null;

  UI.menu=false;
  UI.items=[];
  UI.menuIdx=0;
  UI.queue=[];

  playMessages([
    "BRIOUDE 2026",
    "a tale of AURA",
    "",
    "Appuie sur Entree"
  ]);
}

function startEnding(){
  gameState="ENDING";
  enemy=null;

  UI.menu=false;
  UI.items=[];
  UI.menuIdx=0;
  UI.queue=[];

  playMessages([
    "Bravo.",
    "",
    "MAKE BRIOUDE GREAT AGAIN !",
    "",
    "Appuie sur Entree"
  ]);
}

function startFight(i){
  gameState="FIGHT";
  fightIndex=i;

  const d=CAMPAIGN[i];
  enemy=createFighter(d.name, d.types, d.stats, d.sprite);

  // clone profond des moves (s√©curit√©)
  enemy.moves = d.moves.map(m=>({
    name:m.name, type:m.type, power:m.power,
    effects:(m.effects||[]).map(e=>({ ...e }))
  }));

  resetFighter(player);
  resetFighter(enemy);

  // Menu pr√™t d√®s le d√©but du combat (r√©appara√Æt automatiquement apr√®s les textes)
  openMenu(player.moves.map(m=>m.name));

  playMessages([
    "Un adversaire apparait !",
    d.name+" entre en scene !",
    "Choisis une attaque."
  ]);
}

function resolveTurn(playerMoveIdx){
  if(!enemy) return;
  if(player.hp<=0 || enemy.hp<=0) return;

  const pMove = player.moves[playerMoveIdx];
  const eMove = chooseEnemyMove(enemy, player);
  const order = computeOrder();

  const msgs=[];

  // 1) premier acteur
  for(let step=0; step<2; step++){
    const who = order[step];
    const attacker = (who==="player") ? player : enemy;
    const defender = (who==="player") ? enemy : player;
    const move = (who==="player") ? pMove : eMove;

    if(attacker.hp<=0 || defender.hp<=0) break;

    // Statuts bloquants avant de jouer
    if(!canAct(attacker, msgs)) continue;

    msgs.push(attacker.name+" utilise "+move.name+" !");
    applyMove(attacker, defender, move, msgs);

    if(defender.hp<=0) break;
  }

  // 2) fin de tour : burn tick (1x / tour) + expire protect
  burnTick(player, msgs);
  burnTick(enemy, msgs);
  endTurnTick(player);
  endTurnTick(enemy);

  // 3) check fin de combat
  if(enemy.hp<=0){
    UI.menu=false;
    msgs.push(enemy.name+" est hors debat !");
    msgs.push(CAMPAIGN[fightIndex].quote);
    msgs.push("Appuie sur Entree.");
    playMessages(msgs);
    return;
  }
  if(player.hp<=0){
    UI.menu=false;
    msgs.push("Remy est a court d'arguments...");
    msgs.push("Le debat est perdu.");
    msgs.push("Appuie sur Entree.");
    playMessages(msgs);
    return;
  }

  // 4) combat continue : reset curseur menu
  openMenu(player.moves.map(m=>m.name));
  playMessages(msgs);
}

/* =====================
   INPUT
===================== */
document.addEventListener("keydown",e=>{
  if(UI.cooldown>0) return;

  const key=e.key;

  // √©vite scroll
  if(key==="ArrowUp" || key==="ArrowDown") e.preventDefault();

  // Start depuis TITLE
  if(gameState==="TITLE" && key==="Enter"){
    startFight(0);
    UI.cooldown=180;
    return;
  }

  // Texte prioritaire
  if(UI.text || UI.typing || UI.queue.length){
    if(key==="Enter"){
      const progressed = nextText();

      // Fin de s√©quence de texte
      if(!progressed){

        // ENDING => retour titre
        if(gameState==="ENDING"){
          startTitle();
          UI.cooldown=180;
          return;
        }

        // Encha√Æner campagne apr√®s victoire
        if(gameState==="FIGHT" && enemy && enemy.hp<=0){
          fightIndex++;
          if(fightIndex < CAMPAIGN.length) startFight(fightIndex);
          else startEnding();
          UI.cooldown=180;
          return;
        }

        // D√©faite => retour titre
        if(gameState==="FIGHT" && player.hp<=0){
          startTitle();
          UI.cooldown=180;
          return;
        }

        // Sinon : on laisse le menu s'afficher (il est d√©j√† pr√™t)
      }

      UI.cooldown=120;
    }
    return;
  }

  // Menu (combat)
  if(gameState==="FIGHT" && UI.menu){
    if(key==="ArrowUp") UI.menuIdx=(UI.menuIdx+UI.items.length-1)%UI.items.length;
    if(key==="ArrowDown") UI.menuIdx=(UI.menuIdx+1)%UI.items.length;
    if(key==="Enter"){
      resolveTurn(UI.menuIdx);
      UI.cooldown=120;
    }
  }

  // ENDING : garde-fou si √©cran vide
  if(gameState==="ENDING" && key==="Enter"){
    startTitle();
    UI.cooldown=180;
    return;
  }
});

/* =====================
   DRAW HELPERS
===================== */
function drawBox(x,y,w,h){
  if(IMG.textbox){
    ctx.drawImage(IMG.textbox,x,y,w,h);
    return;
  }
  ctx.fillStyle="#f8f8f8";
  ctx.fillRect(x,y,w,h);
  ctx.strokeStyle="#111";
  ctx.strokeRect(x,y,w,h);
}

function drawHPBar(x,y,hpVis,maxHP){
  const w=60, h=5;
  const ratio = (maxHP<=0)?0:(hpVis/maxHP);
  const filled = Math.floor(w*clamp(ratio,0,1));

  ctx.fillStyle="#111";
  ctx.fillRect(x-1,y-1,w+2,h+2);
  ctx.fillStyle="#eee";
  ctx.fillRect(x,y,w,h);

  let col="#2a7";
  if(filled<14) col="#c22";
  else if(filled<30) col="#ca2";

  ctx.fillStyle=col;
  ctx.fillRect(x,y,filled,h);
}

function drawSprite(key,x,y,bounce=0){
  const img=IMG[key];
  if(img){
    ctx.drawImage(img,x,y-bounce,64,64);
  } else {
    ctx.fillStyle="#333";
    ctx.fillRect(x,y,64,64);
    ctx.fillStyle="#111";
    ctx.fillText(key,x+4,y+16);
  }
}

function drawOverlay(){
  if(!FX.overlay) return;
  const {kind,x,y,t}=FX.overlay;
  ctx.fillStyle="#111";
  ctx.textAlign="center";

  if(kind==="confusion"){
    const dx = Math.sin(t/3)*4;
    ctx.fillText("???", x+dx, y-18);
  } else if(kind==="sleep"){
    ctx.fillText("Zzz", x, y-18);
  } else if(kind==="burn"){
    ctx.fillText("üî•", x, y-18);
  } else if(kind==="protect"){
    ctx.fillText("‚õ®", x, y-18);
  } else if(kind==="heal"){
    ctx.fillText("+", x, y-18);
  }

  ctx.textAlign="left";
}

function drawFloatTexts(){
  ctx.fillStyle="#111";
  ctx.textAlign="center";
  FX.floatTexts.forEach(ft=>{
    ctx.fillText(ft.text, ft.x, ft.y);
  });
  ctx.textAlign="left";
}

function drawTextbox(){
  if(!UI.text && !UI.typing && UI.queue.length===0) return;
  drawBox(8,168,304,64);
  ctx.fillStyle="#111";
  const lines=(UI.visible||UI.text).split("\n");
  for(let i=0;i<Math.min(3,lines.length);i++){
    ctx.fillText(lines[i],16,188+i*14);
  }
}

function drawMenu(){
  if(!UI.menu) return;
  drawBox(8,168,304,64);
  ctx.fillStyle="#111";

  for(let i=0;i<Math.min(4,UI.items.length);i++){
    const y=188+i*14;
    if(i===UI.menuIdx){
      if(IMG.cursor) ctx.drawImage(IMG.cursor, 16, y-10, 12, 12);
      else ctx.fillText("‚ñ∂",16,y);
    }
    ctx.fillText(UI.items[i],32,y);
  }
}

function drawBattle(){
  if(IMG.battle) ctx.drawImage(IMG.battle,0,0,W,H);
  else{
    ctx.fillStyle="#e9e2b8";
    ctx.fillRect(0,0,W,H);
  }

  const enemyBounce = FX.hitAnim.enemy>0 ? (FX.hitAnim.enemy%2?2:1) : 0;
  const playerBounce = FX.hitAnim.player>0 ? (FX.hitAnim.player%2?2:1) : 0;

  if(enemy) drawSprite(enemy.sprite, 210, 40, enemyBounce);
  drawSprite(player.sprite, 40, 110, playerBounce);

  // HUD enemy
  if(enemy){
    drawBox(12,12,170,56);
    ctx.fillStyle="#111";
    ctx.fillText(enemy.name,18,26);
    ctx.fillText(enemy.types.join(" / "),18,38);
    drawHPBar(18,44,enemy.hpVis,enemy.maxHP);
    ctx.fillText(`HP ${Math.round(enemy.hpVis)}/${enemy.maxHP}`, 18, 60);
  }

  // HUD player
  drawBox(138,112,174,56);
  ctx.fillStyle="#111";
  ctx.fillText("Remy",144,128);
  ctx.fillText(player.types.join(" / "),144,142);

  // HP bar plus bas -> ne superpose pas le texte
  drawHPBar(144,148,player.hpVis,player.maxHP);
  ctx.fillText(`HP ${Math.round(player.hpVis)}/${player.maxHP}`,144,162);

  drawOverlay();
  drawFloatTexts();
}

/* =====================
   LOOP
===================== */
let last=performance.now();

function updateHpVisuals(dt){
  const speed = 80 * (dt/1000);

  const stepToward = (cur, target) => {
    if(Math.abs(cur-target) < 0.2) return target;
    if(cur < target) return Math.min(target, cur + speed);
    return Math.max(target, cur - speed);
  };

  player.hpVis = stepToward(player.hpVis, player.hp);
  if(enemy) enemy.hpVis = stepToward(enemy.hpVis, enemy.hp);
}

function loop(now){
  const dt=now-last; last=now;
  if(UI.cooldown>0) UI.cooldown-=dt;

  updateText(dt);
  updateFX();
  updateHpVisuals(dt);

  ctx.save();
  ctx.translate(FX.shakeX, FX.shakeY);

  // TITLE / ENDING = √©cran texte
  if(gameState==="TITLE" || gameState==="ENDING"){
    ctx.fillStyle="#f3f0da";
    ctx.fillRect(0,0,W,H);
    ctx.fillStyle="#111";
    ctx.textAlign="center";
    ctx.fillText("BRIOUDE 2026",160,80);
    ctx.fillText("a tale of AURA",160,96);
    ctx.textAlign="left";
    drawTextbox();
  } else {
    drawBattle();
    if(UI.text || UI.typing || UI.queue.length) drawTextbox();
    else drawMenu();
  }

  ctx.restore();

  if(FX.flashFrames>0){
    ctx.fillStyle="rgba(255,255,255,0.6)";
    ctx.fillRect(0,0,W,H);
  }

  requestAnimationFrame(loop);
}

/* =====================
   BOOT
===================== */
preloadAssets(()=>{
  startTitle();
  requestAnimationFrame(loop);
});

})();
</script>

</body>
</html>
